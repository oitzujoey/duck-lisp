(__defmacro defmacro (name parameters &rest body) (__cons (__quote __defmacro) (__cons name (__cons parameters body))))
(defmacro quote (form) (__list (__quote __quote) form))
(defmacro list (&rest parameters) (__cons (quote __list) parameters))
(defmacro comment (&rest words) ())
(defmacro cons (first second) (list (quote __cons) first second))
(defmacro nop () (list (quote __nop)))
(defmacro noscope (&rest body) (cons (quote __noscope) body))
(defmacro comptime (&rest body) (cons (quote __comptime) body))
(defmacro var (variable value) (list (quote __var) variable value))
(defmacro setq (variable value) (list (quote __setq) variable value))
(defmacro global (variable value) (list (quote __global) variable value))
(defmacro defun (name parameters &rest body) (cons (quote __defun) (cons name (cons parameters body))))
(defmacro lambda (parameters &rest body) (cons (quote __lambda) (cons parameters body)))
(defmacro funcall (function &rest arguments) (cons (quote __funcall) (cons function arguments)))
(defmacro apply (function &rest arguments) (cons (quote __apply) (cons function arguments)))
(defmacro if (condition then else) (list (quote __if) condition then else))
(defmacro when (condition then) (list (quote __when) condition then))
(defmacro unless (condition else) (list (quote __when) condition else))
(defmacro while (condition &rest body) (cons (quote __while) (cons condition body)))
(defmacro vector (&rest arguments) (cons (quote __vector) arguments))
(defmacro error (string) (list (quote __error) string))

(defmacro bothtime (&rest body)
  (list (quote noscope)
        (cons (quote comptime)
              body)
        (cons (quote noscope)
              body)))

(defmacro cvar (name value)
  (funcall comptime (list (quote var) name value) ()))

(defmacro cdefun (name parameters &rest body)
  (var defun (list (quote __defun) name parameters))
  (__set-cdr (__cdr (__cdr defun)) body)
  (funcall comptime defun ()))

(defmacro bvar (name value)
  (funcall bothtime (list (quote var) name value) ()))

(defmacro bdefun (name parameters &rest body)
  (var defun (list (quote __defun) name parameters))
  (__set-cdr (__cdr (__cdr defun)) body)
  (funcall bothtime defun ()))

(defmacro make-vector (size init) (__list (__quote __make-vector) size init))
(defmacro get-vector-element (vector index) (__list (__quote __get-vector-element) vector index))
(defmacro set-vector-element (vector index value) (__list (__quote __set-vector-element) vector index value))
(defmacro car (cons) (__list (__quote __car) cons))
(defmacro cdr (cons) (__list (__quote __cdr) cons))
(defmacro set-car (cons value) (__list (__quote __set-car) cons value))
(defmacro set-cdr (cons value) (__list (__quote __set-cdr) cons value))
(defmacro make-string (integer-sequence) (__list (__quote __make-string) integer-sequence))
(defmacro make-type () (__list (__quote __make-type)))
(defmacro make-instance (type value-slot function-slot) (__list (__quote __make-instance) type value-slot function-slot))
(defmacro composite-value (composite) (__list (__quote __composite-value) composite))
(defmacro composite-function (composite) (__list (__quote __composite-function) composite))
(defmacro set-composite-value (composite value) (__list (__quote __set-composite-value) composite value))
(defmacro set-composite-function (composite function) (__list (__quote __set-composite-function) composite function))
(defmacro null? (value) (__list (__quote __null?) value))
(defmacro type-of (value) (__list (__quote __type-of) value))
(defmacro not (value) (__list (__quote __not) value))
(defmacro * (a b) (__list (__quote __*) a b))
(defmacro / (a b) (__list (__quote __/) a b))
(defmacro + (a b) (__list (__quote __+) a b))
(defmacro - (a b) (__list (__quote __-) a b))
(defmacro = (a b) (__list (__quote __=) a b))
(defmacro < (a b) (__list (__quote __<) a b))
(defmacro > (a b) (__list (__quote __>) a b))
(defmacro ≠ (a b) (__list (__quote __not) (__list (__quote __=) a b)))
(defmacro ≥ (a b) (__list (__quote __not) (__list (__quote __<) a b)))
(defmacro ≤ (a b) (__list (__quote __not) (__list (__quote __>) a b)))


(cdefun reverse (list)
        (var new-list ())
        (while (not (null? list))
          (setq new-list (cons (car list) new-list))
          (setq list (cdr list)))
        new-list)
(cvar nreverse reverse)

(defmacro and (&rest args)
  (setq args (reverse args))
  (var form true)
  (while (not (null? args))
    (setq form (list (quote if)
                     (car args)
                     form
                     false))    
    (setq args (cdr args)))
  form)

(defmacro or (&rest args)
  (setq args (reverse args))
  (var form false)
  (while (not (null? args))
    (setq form (list (quote if)
                     (car args)
                     true
                     form))    
    (setq args (cdr args)))
  form)

(cdefun mapcar* (fun list)
        (var returns ())
        (while (not (null? list))
          (setq returns (cons (fun (car list))
                              returns))
          (setq list (cdr list)))
        returns)
(cvar mapcar mapcar*)

(cdefun list* (&rest args)
        (setq args (reverse args))
        (var list (car args))
        (setq args (cdr args))
        (while (not (null? args))
          (setq list (cons (car args) list))
          (setq args (cdr args)))
        list)

(comment Not the typical `dotimes'.
         (dotimes i 4
                  (println i))
         In the above example, the numbers 0-3 are printed.
         `top' is only evaluated once. Returns `top'.)
(defmacro dotimes (variable top &rest body)
  (var top-var (gensym))
  (list
   (list (quote var) variable 0)
   (list (quote var) top-var top)
   (list (quote while) (list (quote <) variable top-var)
         (list* (quote noscope) body)
         (list (quote setq) variable (list (quote +) 1 variable)))
   top-var))

(defmacro const (name value)
  (list (quote comptime) (list (quote var) name value)))

(const fio0dir 0x2009C000)
(const fio1dir 0x2009C020)
(const fio2dir 0x2009C040)
(const fio3dir 0x2009C060)
(const fio4dir 0x2009C080)

(const fio0mask 0x2009C010)
(const fio1mask 0x2009C030)
(const fio2mask 0x2009C050)
(const fio3mask 0x2009C070)
(const fio4mask 0x2009C090)

(const fio0pin 0x2009C014)
(const fio1pin 0x2009C034)
(const fio2pin 0x2009C054)
(const fio3pin 0x2009C074)
(const fio4pin 0x2009C094)

(const red-led-port-direction (comptime fio0dir))
(const red-led-port (comptime fio0pin))
(const red-led-mask 0x00400000)
(const green-led-port-direction (comptime fio3dir))
(const green-led-port (comptime fio3pin))
(const green-led-mask 0x02000000)
(const blue-led-port-direction (comptime fio3dir))
(const blue-led-port (comptime fio3pin))
(const blue-led-mask 0x04000000)

(cdefun hex-digit-to-integer (char)
        (var zero (car "0"))
        (if (and (≤ zero char) (≤ char (car "9")))
            (- char zero)
            (+ 10 (- char (car "A")))))

(cdefun read-mem-file (file-name)
        (var EOF -1)
        (var SPACE (car " "))
        (var LN (car "\n"))
        (var CR 0x0d)
        (defun whitespace? (char)
          (or (= char SPACE)
              (= char LN)
              (= char CR)))
        (var file (open-file file-name "r"))
        (var finished false)
        (var char-list ())
        (while (not finished)
          (var char (fgetc file))
          (setq finished (= char EOF))
          (when (not finished)
            (setq char-list (cons char char-list))))
        (var string (make-string (reverse char-list)))
        (setq char-list ())
        (while (not (null? string))
          (var char (car string))
          (if (whitespace? char)
              ()
              (setq char-list (cons char char-list)))
          (setq string (cdr string)))
        (var hex-string (make-string (reverse char-list)))
        (setq char-list ())
        (while (not (null? hex-string))
          (setq char-list (cons (+ (hex-digit-to-integer (car (cdr hex-string)))
                                   (* 16 (hex-digit-to-integer (car hex-string))))
                                char-list))
          (setq hex-string (cdr (cdr hex-string))))
        (make-string (reverse char-list)))

(bvar high true)
(bvar low false)
(bvar out true)
(bvar in false)

(comment Initialize GPIO)
(write-µcode-buffer-oe high)
(write-µcode-state-oe high)
(write-µcode-we high)
(write-µcode-oe high)
(write-clock low)

(defmacro toggle-clock ()
  (list (quote noscope)
        (list (quote write-clock) low)
        (list (quote write-clock) high)))

(cvar mem-file-names (list "/mnt/c/Users/joey/Documents/Computing/Computer Hardware/My Computers/Homebrew Processors/MicroComp/microcode/v1.1.2/microcode-v1.1.2-1.mem"
                           "/mnt/c/Users/joey/Documents/Computing/Computer Hardware/My Computers/Homebrew Processors/MicroComp/microcode/v1.1.2/microcode-v1.1.2-2.mem"
                           "/mnt/c/Users/joey/Documents/Computing/Computer Hardware/My Computers/Homebrew Processors/MicroComp/microcode/v1.1.2/microcode-v1.1.2-3.mem"))
(comment (global binaries (comptime (mapcar read-mem-file mem-file-names))))

(defmacro log (form)
  (list (quote noscope)
        form
        (list (quote print)
              (list (quote quote)
                    form))
        (list (quote print) "\n")
        (list (quote rad))))

(defun rad ()
  (print (cons (µcode-address-read) (µcode-data-read)))
  (print "\n"))

(µcode-data-set-direction out)
(µcode-address-set-direction out)

(var top 0x40)
(defun calculate (i)
  ;; There could be a bug with literal values. Be sure to print this out once to make sure the sequence looks correct.
  (+ i (+ (* 0x100 i) (* 0x100 (* 0x100 i)))))
(dotimes i top
  (µcode-data-write (calculate i))
  (µcode-address-write i)
  (write-µcode-we low)
  (rad)
  (write-µcode-we high))
(µcode-data-set-direction in)
(print "WRITE DONE\n")

(write-µcode-oe low)
(dotimes i top
         (µcode-address-write i)
         (print (µcode-address-read)) (print " ") (print (µcode-data-read)) (print " ") (print (- (calculate i) (µcode-data-read))) (print "\n"))
(write-µcode-oe high)
(print "READ DONE\n")

(comment Bit 7 is stuck low and bit 6 is stuck high)
